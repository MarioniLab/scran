#' Quickly perform pseudo-bulk DE analyses
#'
#' A wrapper function around \pkg{edgeR}'s quasi-likelihood methods
#' to conveniently perform differential expression analyses on pseudo-bulk profiles,
#' allowing detection of cell type-specific changes between conditions in replicated studies.
#'
#' @param x For the ANY method, a numeric matrix of counts where rows are genes and columns are pseudo-bulk profiles.
#'
#' For the \linkS4class{SummarizedExperiment} method, a SummarizedExperiment object containing such a matrix in its assays.
#' @param sample A vector or factor of length equal to \code{ncol(x)},
#' specifying the sample of origin for each column of \code{x}.
#' @param label A vector of factor of length equal to \code{ncol(x)},
#' specifying the cluster or cell type assignment for each column of \code{x}.
#' @param design 
#' A numeric matrix containing the experimental design for the multi-sample comparison.
#' The number of rows should be equal to the total number of samples and the row names should be unique levels of \code{samples}.
#' @param condition 
#' A vector or factor of length equal to \code{nrow(design)},
#' specifying the experimental condition for each sample (i.e., row of \code{design}).
#' Only used for filtering.
#' @param coef Integer scalar or vector indicating the coefficients to drop from \code{design} to form the null hypothesis.
#' @param contrast Numeric vector or matrix containing the contrast of interest.
#' Takes precedence over \code{coef}.
#' @param lfc Numeric scalar specifying the log-fold change threshold to use in \code{\link{glmTreat}}.
#' @param assay.type String or integer scalar specifying the assay to use from \code{x}.
#' @param ... For the generic, additional arguments to pass to individual methods.
#'
#' For the SummarizedExperiment method, additional arguments to pass to the ANY method.
#' 
#' @return A \linkS4class{List} with one \linkS4class{DataFrame} of DE results per unique level of \code{cluster}.
#' This will contain at least the fields \code{"LogCPM"}, \code{"PValue"} and \code{"FDR"},
#' and usually \code{"logFC"} depending on whether an ANOVA-like contrast is requested in \code{coef} or \code{contrast}.
#' All DataFrames have row names equal to \code{rownames(x)}.
#' 
#' The \code{\link{metadata}} of the List contains \code{failed},
#' a character vector with the names of the labels for which the comparison could not be performed,
#' e.g., due to lack of residual d.f. 
#'
#' @details
#' In replicated multi-condition scRNA-seq experiments,
#' we often have clusters comprised of cells from different samples of different experimental conditions.
#' It is often desirable to check for differential expression between conditions within each cluster,
#' allowing us to identify cell-type-specific responses to the experimental perturbation.
#'
#' Given a set of pseudo-bulk profiles (usually generated by \code{\link{sumCountsAcrossCells}}),
#' this function loops over the labels and uses \pkg{edgeR} to detect DE genes between conditions.
#' The DE analysis for each label is largely the same as a standard analysis for bulk RNA-seq data,
#' using \code{design} and \code{coef} or \code{contrast} as described in the \pkg{edgeR} user's guide.
#' The analysis for each label is independent, i.e., the GLM fitting is performed separately,
#' to minimize problems due to differences in abundance and variance between labels.
#'
#' Performing pseudo-bulk DGE enables us to re-use well-tested methods developed for bulk RNA-seq data analysis.
#' Each pseudo-bulk profile can be treated as an \emph{in silico} mimicry of a real bulk RNA-seq sample
#' (though in practice, it tends to be much more variable due to the relatively higher numbers of cells).
#' Pseudo-bulk analysis also allows direct modelling of variability between experimental replicates (i.e., across samples)
#' rather than that between cells in the same sample.
#' The former is more relevant to any statistical analysis that aims to obtain reproducible results.
#'
#' For each label, abundance filtering is performed using \code{\link{filterByExpr}} prior to further analysis.
#' Genes that are filtered out will still show up in the DataFrame for that label, but with all statistics set to \code{NA}.
#' Note that a different set of genes may be filtered out for each label,
#' which is largely to be expected if their abundances change between labels.
#' If \code{condition} is specified, this will instruct \code{filterByExpr} to set the minimum group size
#' according to \code{condition} instead of \code{design}.
#'
#' In some cases, it will be impossible to perform an \pkg{edgeR} analysis as there are no residual degrees of freedom.
#' This will be represented by a DataFrame with log-fold changes but \code{NA} p-values and FDRs.
#' In other cases, all statistics in the DataFrame will be \code{NA} if the contrast cannot be performed,
#' e.g., if a cell type only exists in one condition.
#'
#' Note that we assume that \code{x} has already been filtered to remove unstable pseudo-bulk profiles generated from few cells.
#' 
#' @author Aaron Lun
#'
#' @references
#' Tung P-Y et al. (2017).
#' Batch effects and the effective design of single-cell gene expression studies.
#' \emph{Sci. Rep.} 7, 39921
#' 
#' Lun ATL and Marioni JC (2017).
#' Overcoming confounding plate effects in differential expression analyses of single-cell RNA-seq data.
#' \emph{Biostatistics} 18, 451-464
#'
#' Crowell HL et al. (2019).
#' On the discovery of population-specific state transitions from multi-sample multi-condition single-cell RNA sequencing data.
#' \emph{biorXiv}
#'
#' @examples
#' set.seed(10000)
#' library(scater)
#' sce <- mockSCE(ncells=1000)
#' sce$samples <- gl(8, 125) # Pretending we have 8 samples.
#'
#' # Making up some clusters.
#' sce <- logNormCounts(sce)
#' clusters <- kmeans(t(logcounts(sce)), centers=3)$cluster
#'
#' # Creating a set of pseudo-bulk profiles:
#' info <- DataFrame(sample=sce$samples, cluster=clusters)
#' pseudo <- sumCountsAcrossCells(sce, info)
#'
#' # Determining the experimental design for our 8 samples.
#' DRUG <- gl(2,4)
#' design <- model.matrix(~DRUG)
#' rownames(design) <- seq_len(8)
#' 
#' # DGE analysis:
#' out <- pseudoBulkDGE(pseudo, 
#'    sample=pseudo$sample, 
#'    label=pseudo$cluster,
#'    design=design
#' )
#' @seealso
#' \code{\link{sumCountsAcrossCells}}, to easily generate the pseudo-bulk count matrix.
#'
#' \code{\link{decideTestsPerLabel}}, to generate a summary of the DE results across all labels.
#'
#' \code{pbDS} from the \pkg{muscat} package, which uses a similar approach.
#' @name pseudoBulkDGE
NULL

#' @importFrom S4Vectors DataFrame List metadata metadata<-
#' @importFrom edgeR DGEList estimateDisp glmQLFit glmQLFTest calcNormFactors filterByExpr topTags glmLRT glmFit glmTreat
.pseudo_bulk_dge <- function(x, sample, label, design, coef=ncol(design), contrast=NULL, condition=NULL, lfc=0) {
    sample <- as.character(sample)
    label <- as.character(label)

    if (!identical(sort(rownames(design)), sort(unique(sample)))) {
        stop("'rownames(design)' and 'sample' should have the same levels")
    }

    de.results <- list()
    failed <- character(0)

    for (i in sort(unique(label))) {
        chosen <- i==label

        curx <- x[,chosen,drop=FALSE]
        y <- DGEList(curx, samples=data.frame(sample=sample[chosen], stringsAsFactors=FALSE))

        m <- match(as.character(y$samples$sample), rownames(design))
        curdesign <- design[m,,drop=FALSE]
        curcond <- condition[m]

        gkeep <- filterByExpr(y, design=curdesign, group=curcond)
        y <- y[gkeep,]
        y <- calcNormFactors(y)

        rank <- qr(curdesign)$rank
        if (rank == nrow(curdesign) || rank < ncol(curdesign)) { 
            res <- try({ 
                fit <- glmFit(y, curdesign, dispersion=0.05)
                if (lfc==0) {
                    glmLRT(fit, coef=coef, contrast=contrast)
                } else {
                    glmTreat(fit, lfc=lfc, coef=coef, contrast=contrast)
                }
            }, silent=TRUE)

            if (is(res, "try-error")) {
                refnames <- c("logFC", if (lfc!=0) "unshrunk.logFC", "logCPM", "PValue", "LR", "FDR")
                empty <- lapply(refnames, function(i) rep(NA_real_, nrow(x)))
                names(empty) <- refnames
                empty <- DataFrame(empty, row.names=rownames(x))
                de.results[[i]] <- empty
                next
            } else {
                res$table$PValue <- rep(NA_real_, nrow(res$table))
            }

            failed <- c(failed, i)
        } else {
            y <- estimateDisp(y, curdesign)
            fit <- glmQLFit(y, curdesign, robust=TRUE)

            if (lfc==0) {
                res <- glmQLFTest(fit, coef=coef, contrast=contrast)
            } else {
                res <- glmTreat(fit, lfc=lfc, coef=coef, contrast=contrast)
            }
        }

        tab <- topTags(res, n=Inf, sort.by="none")
        expander <- match(seq_len(nrow(x)), which(gkeep))
        tab <- DataFrame(tab$table[expander,,drop=FALSE])
        rownames(tab) <- rownames(x)
        de.results[[i]] <- tab
    }

    output <- List(de.results)
    metadata(output)$failed <- failed
    output
}

#' @export
#' @rdname pseudoBulkDGE
setGeneric("pseudoBulkDGE", function(x, ...) standardGeneric("pseudoBulkDGE"))

#' @export
#' @rdname pseudoBulkDGE
setMethod("pseudoBulkDGE", "ANY", .pseudo_bulk_dge)

#' @export
#' @rdname pseudoBulkDGE
#' @importFrom SummarizedExperiment assay
setMethod("pseudoBulkDGE", "SummarizedExperiment", function(x, ..., assay.type=1) {
    .pseudo_bulk_dge(assay(x, assay.type), ...)
})
