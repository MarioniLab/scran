% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scoreMarkers.R
\name{scoreMarkers}
\alias{scoreMarkers}
\alias{scoreMarkers,ANY-method}
\alias{scoreMarkers,SummarizedExperiment-method}
\alias{scoreMarkers,SingleCellExperiment-method}
\title{Score marker genes}
\usage{
scoreMarkers(x, groups, ...)

\S4method{scoreMarkers}{ANY}(
  x,
  groups,
  block = NULL,
  design = NULL,
  weight.fun = NULL,
  row.data = NULL,
  full.stats = FALSE,
  BPPARAM = SerialParam()
)

\S4method{scoreMarkers}{SummarizedExperiment}(x, groups, ..., assay.type = "logcounts")

\S4method{scoreMarkers}{SingleCellExperiment}(x, groups = colLabels(x, onAbsence = "error"), ...)
}
\arguments{
\item{x}{A matrix-like object containing log-normalized expression values, with genes in rows and cells in columns.
Alternatively, a \linkS4class{SummarizedExperiment} object containing such a matrix in its assays.}

\item{groups}{A factor or vector containing the identity of the group for each cell in \code{x}.}

\item{...}{For the generic, further arguments to pass to individual methods.

For the SummarizedExperiment method, further arguments to pass to the ANY method.

For the SingleCellExperiment method, further arguments to pass to the SummarizedExperiment method.}

\item{block, design}{Further arguments to be passed to \code{\link{pairwiseTTest}} and related functions.}

\item{weight.fun}{Function indicating how the statistics from different comparisons should be weighted.
This should accept a vector of integers containing the number of cells involved in the comparison,
and return a vector of equal length containing the weights.}

\item{row.data}{A DataFrame of length equal to \code{nrow(x)}, containing extra information to insert into each DataFrame.}

\item{full.stats}{Logical scalar indicating whether the statistics from the pairwise comparisons should be directly returned.}

\item{BPPARAM}{A \linkS4class{BiocParallelParam} object specifying how the calculations should be parallelized.}
}
\value{
A List of DataFrames containing marker scores for each gene in each group.
Each DataFrame corresponds to a group and each row corresponds to a gene in \code{x}.
See Details for information about the individual columns.
}
\description{
Compute various summary scores for potential marker genes to distinguish between groups of cells.
}
\details{
Compared to \code{\link{findMarkers}}, this function represents a simpler and more intuitive summary of the differences between the groups.
We do this by realizing that the p-values for these types of comparisons are largely meaningless;
individual cells are not meaningful units of experimental replication, while the groups themselves are defined from the data.
Thus, by discarding the p-values, we can simplify our marker selection by focusing only on the effect sizes between groups.

Here, the strategy is to perform pairwise comparisons between each pair of groups to obtain various effect sizes.
For each group \eqn{X}, we summarize the effect sizes across all pairwise comparisons involving that group, e.g., mean, min, max and so on.
This yields a DataFrame for each group where each column contains a different summarized effect and each row corresponds to a gene in \code{x}.
Reordering the rows by the summary of choice can yield a ranking of potential marker genes for downstream analyses.

In addition, we report the mean log-expression of all cells in \eqn{X}, as well as the grand mean of mean log-expression values for all other groups.
This can be used to easily compute an overall log-fold change though ranking is best performed on one of the effect sizes described below.
We also report the proportion of cells with detectable expression in \eqn{X} and the mean proportion for all other groups.
}
\section{Choice of effect sizes}{

The \code{logFC.cohen} columns contain the standardized log-fold change, i.e., Cohen's d.
For each pairwise comparison, this is defined as the difference in the mean log-expression for each group scaled by the root of the pooled variance across the groups.
The standardization is analogous to the calculation of the t-statistic and avoids spuriously large effect sizes from highly variable groups.
We can also interpret Cohen's d as the number of standard deviations between the two group means.

The \code{AUC} columns contain the area under the curve.
This is the probability that a randomly chosen observation in one group is greater than a randomly chosen observation in the other group.
The AUC is closely related to the U-statistic used in the Wilcoxon rank sum test.
Values greater than 0.5 indicate that a gene is upregulated in the first group.

The key difference between the AUC and Cohen's d is that the former is less sensitive to the variance within each group.
The clearest example is that of two distributions that exhibit no overlap, where the AUC is the same regardless of the variance of each distribution.
This may or may not be desirable, as it improves robustness to outliers but reduces the information available to obtain a highly resolved ranking. 
The most appropriate choice of effect size is left at the user's discretion.

Finally, the \code{logFC.detected} columns contain the log-fold change in the proportion of cells with detected (i.e., non-zero) expression between groups.
This is specifically useful for detecting binary expression patterns, e.g., activation of an otherwise silent gene.
Note that the non-zero status of the data is not affected by normalization, so differences in library size will implicitly affect the value of this metric.
However, this is not necessarily problematic for marker gene detection - users can treat this as \emph{retaining} information about the total RNA content, analogous to spike-in normalization.
}

\section{Computing effect size summaries}{

To simplify interpretation, we summarize the effect sizes across all pairwise comparisons into a few key metrics.
For each group \eqn{X}, we consider the effect sizes from all pairwise comparisons between \eqn{X} and other groups. 
We then compute the following values:
\itemize{
\item \code{mean.*}, the mean effect sze across all pairwise comparisons involving \eqn{X}.
A large value (>0 for log-fold changes, >0.5 for the AUCs) indicates that the gene is upregulated in \eqn{X} compared to the average of the other groups.
\item \code{median.*}, the median effect size across all pairwise comparisons involving \eqn{X}.
A large value indicates that the gene is upregulated in \eqn{X} compared to most (>50\%) other groups.
\item \code{min.*}, the minimum effect size across all pairwise comparisons involving \eqn{X}.
A large value indicates that the gene is upregulated in \eqn{X} compared to all other groups,
while a small value (<0 for log-fold changes, <0.5 for the AUCs) indicates that the gene is downregulated in \eqn{X} compared to at least one other group.
\item \code{max.*}, the minimum effect size across all pairwise comparisons involving \eqn{X}.
A large value indicates that the gene is upregulated in \eqn{X} compared to at least one other group,
while a small value indicates that the gene is downregulated in \eqn{X} compared to all other groups.
}

One set of these columns is added to the DataFrame for each effect size described above.
For example, the mean column for the AUC would be \code{mean.AUC}.
We can then reorder each group's DataFrame by our column of choice, depending on which summary and effect size we are interested in.
For example, if we ranked by decreasing \code{min.logFC.detected}, we would be aiming for marker genes that exhibit strong binary increases in expression in \eqn{X} compared to \emph{all} other groups.

The mean is obtained by weighting each comparison according to the number of cells involved.
This ensures that statistics from comparisons with very few cells do not skew the summary.
If \code{weight.fun=NULL}, the default weight is defined as the number of cells, capped at 100 cells;
this upweights comparisons with "enough" cells while ensuring that comparisons involving very large groups do not dominate the summary.

If \code{full.stats=TRUE}, an extra \code{full.*} column is returned in the DataFrame.
This contains a nested DataFrame with number of columns equal to the number of other groups.
Each column contains the statistic from the comparison between \eqn{X} and the other group.
}

\examples{
library(scuttle)
sce <- mockSCE()
sce <- logNormCounts(sce)

# Any clustering method is okay, only using k-means for convenience.
kout <- kmeans(t(logcounts(sce)), centers=4) 

out <- scoreMarkers(sce, groups=kout$cluster)
out

of.interest <- out[[1]]
of.interest[order(of.interest$min.logFC.detected, decreasing=TRUE),]

}
\author{
Aaron Lun
}
